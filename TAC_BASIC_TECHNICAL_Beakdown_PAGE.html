<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TAC  V0.0.4 @ 2021.04.07: Technical breakdown of the modules</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="TACdoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="TAC_navtree_hacks.js"></script>
</head>
<body>
<div style="background:#FFDDDD;font-size:120%;text-align:center;margin:0;padding:5px">Please, help us to better know about our user community by answering the following short survey:  <a href="https://forms.gle/wpyrxWi18ox9Z5ae9">https://forms.gle/wpyrxWi18ox9Z5ae9</a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="TAC_Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://jvegh@bitbucket.org/jvegh/timeawarecomputingsimulator">TAC  V0.0.4 @ 2021.04.07</a>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('TAC_BASIC_TECHNICAL_Beakdown_PAGE.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Technical breakdown of the modules </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#TAC_BASIC_TECHNICAL_Breakdown_Topology">The topology</a><ul><li class="level2"><a href="#TAC_BASIC_TECHNICAL_Breakdown_GridPoint">The GridPoints of the topology</a></li>
<li class="level2"><a href="#TAC_BASIC_TECHNICAL_Breakdown_Grid">The grid, the logical assembly of grid points</a><ul><li class="level3"><a href="#TAC_BASIC_TECHNICAL_Breakdown_ClusterDistance">The distance of gridpoints</a></li>
<li class="level3"><a href="#TAC_BASIC_TECHNICAL_Breakdown_ClusterAddress">The cluster addressing</a></li>
<li class="level3"><a href="#TAC_BASIC_TECHNICAL_Breakdown_ClusterTypes">Cluster types</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#TAC_BASIC_TECHNICAL_Breakdown_Modules">The modules</a><ul><li class="level2"><a href="#TAC_BASIC_TECHNICAL_Breakdown_scGridPoint">The communicating grid point</a></li>
<li class="level2"><a href="#TAC_BASIC_TECHNICAL_Breakdown_scHThreads">HThreads and computing resources</a></li>
<li class="level2"><a href="#TAC_BASIC_TECHNICAL_Breakdown_HexaExtended">The extended cluster</a></li>
<li class="level2"><a href="#TAC_BASIC_TECHNICAL_Breakdown_scProcessor">The processor comprising scGridPoint modules</a></li>
<li class="level2"><a href="#TAC_BASIC_TECHNICAL_Breakdown_MessageRouting">Message routing</a></li>
</ul>
</li>
<li class="level1"><a href="#BASE_TECHNICAL_GUIDE_ClusterBus">The ClusterBus</a><ul><li class="level2"><a href="#BASE_TECHNICAL_GUIDE_ClusterBus_Hierarchy">The hierarchic buses</a></li>
<li class="level2"><a href="#BASE_TECHNICAL_GUIDE_ClusterBus_Scheme">The scClusterBus scheme</a></li>
<li class="level2"><a href="#BASE_TECHNICAL_GUIDE_ClusterBus_MasterSlave">Masters and slaves</a></li>
<li class="level2"><a href="#TAC_BASIC_TECHNICAL_Breakdown_IGPCB">The inter-gridpoint communication block</a></li>
</ul>
</li>
<li class="level1"><a href="#TAC_BASIC_TECHNICAL_Addressing_GROUPING">Module grouping</a><ul><li class="level2"><a href="#TAC_BASIC_TECHNICAL_Addressing_CLUSTER">The Hexagonal cluster</a></li>
<li class="level2"><a href="#TAC_BASIC_TECHNICAL_Addressing_ProxyModules">The proxy modules</a></li>
<li class="level2"><a href="#TAC_BASIC_TECHNICAL_Addressing_ClusterHead">The cluster head</a></li>
<li class="level2"><a href="#TAC_BASIC_TECHNICAL_Addressing_ClusterPhantom">The phantom clusters</a></li>
</ul>
</li>
<li class="level1"><a href="#TAC_BASIC_TECHNICAL_Addressing_LOGICAL">Module&#39;s hierarchic logical addressing</a><ul><li class="level2"><a href="#TAC_BASIC_TECHNICAL_Addressing_PHYSICAL">The physical address</a></li>
<li class="level2"><a href="#TAC_BASIC_TECHNICAL_Addressing_ClusterAddress">The cluster addressing</a></li>
</ul>
</li>
<li class="level1"><a href="#TAC_BASIC_TECHNICAL_Addressing_HIERARCHIC">Hierarchic communication</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="TAC_BASIC_TECHNICAL_Breakdown_Topology"></a>
The topology</h1>
<p>The basic package explicitly assumes that a large number of electronic modules are used in connection with each other. The present electronic manufacturing technology enables to place those modules on a 2-dimensional surface (in several layers) as described in section <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#TAC_BASIC_TECHNICAL_Addressing_GROUPING">Module grouping</a>. When considering the connectivity of the modules, from the point of view of wiring, signal timing, transmission time, etc. the topological position can be important, so the package enables to place the modules at well-defined positions and also provides topology-based communication elements between the modules. During the communication this information is actively used to make message routing more effective.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Breakdown_GridPoint"></a>
The GridPoints of the topology</h2>
<p>Today, on a Si die a lot of modules are placed, arranged in a rectangular form. Usually they are the same "intellectual property", simply cloned to different places and being segregated from each other. As shown, the <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a> objects have X<sub>P</sub> and Y<sub>P</sub> <em>positions</em> formed from the X and Y <em>coordinates</em>. All these are proper physical addresses.</p>
<p>The <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a> class simply introduces the concept that the electronic modules <b>have</b> topological position (and so: neighbors and distances from each other) and they can maintain some kind of relationship with the fellow gridpoints. However, <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a> is a math-only class.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Breakdown_Grid"></a>
The grid, the logical assembly of grid points</h2>
<p>The <a class="el" href="classAbstractTopology.html">AbstractTopology</a> is also a math-only class: given that the modules are <em>technologically</em> arranged according to a 2-dimensional grid, the grid points points are arranged into also a 2-dimensional grid and they can be addressed through using their X and Y coordinates. The grid points (having identical internal structure) may be more conveniently addressed with a simple sequence number (i.e. they are arranged in a vector, and they can be addressed through their index).</p>
<h3><a class="anchor" id="TAC_BASIC_TECHNICAL_Breakdown_ClusterDistance"></a>
The distance of gridpoints</h3>
<p>For the <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a> objects arranged in a way like this, a <em>distance</em> can also be interpreted. The zero distance means the module itself. The distance is one, if the modules have a common boundary, and the distance is two if they have a common neighbor.</p>
<p>The native form of grouping the modules into a higher-level unit is clustering them. The hexagonal arrangement enables to surround a module with 6 other modules, see the "flowers" on the figure <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#Fig_Hexagona2">Fig_Hexagona2</a>. These 6 modules are first-order neighbors (or internal members of the cluster). Normally, in the case of complete clusters, see below, only the first order members belong to the cluster (of course in addition to the zeroth-order member, the cluster head), but in emergency cases (see the phantom clusters below) some second order members are also be attached to the cluster.</p>
<h3><a class="anchor" id="TAC_BASIC_TECHNICAL_Breakdown_ClusterAddress"></a>
The cluster addressing</h3>
<p>As mentioned, a <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a> can be described by its rectangular coordinates (X,Y), by the topological position coordinates (X<sub>P</sub>,Y<sub>P</sub>) and they can be described also by a simple sequence number N. The clustering provides one more option: the gridpoints can be <em>logically</em> addressed through their corresponding <em>cluster address</em> (C,M), where C is the sequence number of the cluster and M describes the member relative to the cluster head. All the mentioned module IDs are unique and can properly identify the module: they are all referring to the same physical unit.</p>
<h3><a class="anchor" id="TAC_BASIC_TECHNICAL_Breakdown_ClusterTypes"></a>
Cluster types</h3>
<p>As shown in the figure, the clusters inside the square grid (i.e. when all logical grid points of a cluster can be mapped to physical modules) are <em>complete cluster</em>s: the head and all members are physically present (i.e. all they can be mapped to physical modules). At the edges of the square grid, some clusters are only partly present. These <em>incomplete cluster</em>s can map their cluster head to a physical module, but not all of their members correspond to a physical module: the hexagons corresponding to the missing modules are filled with light violet. There are also some <em>phantom cluster</em>s: the cluster head cannot be mapped to a physical module, but at least one of its members can. These hexagons have white background.</p>
<h1><a class="anchor" id="TAC_BASIC_TECHNICAL_Breakdown_Modules"></a>
The modules</h1>
<p>Here the basic elements comprised in the package are described. The elements, signals, etc. primarily named and used as usual in the electronics. In the other two packages the same basic elements are used for subclassing the basic modules of those blocks, under a different name. In this booklet only the base functionality and operation is described. The other booklets are intended to be self-contained, but the interested reader may want to know, how those facilities are established in the deeper layers.</p>
<p>One of the focal points is to organize the communication differently. Another point is to provide flexibility (morphing the architecture), in addition to the conventional way of operation. In the package the inter-module communication is implemented as background activity. The foreground activity is cut into two mutually exclusive parts: the modules either work in a conventional way or they are morphing. Since morphing may involve other <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> modules, those operation can only be carried out with the assistance of the <a class="el" href="classscProcessor.html" title="Implements a module-name alias facility (i.e., user-provided names. Given that the basic units is scH...">scProcessor</a>, that is reponsible for the operation of the system.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Breakdown_scGridPoint"></a>
The communicating grid point</h2>
<p>The <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> is an anchestor class of electronic modules (sc_core::sc_module <a class="el" href="citelist.html#CITEREF_SystemCBook:2010">[2]</a>) with communication facilities. It knows its topological position (it is a <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a>), can communicate autonomously and independently from its payload activity. It is a good anchestor for both cooperating (nearly) conventional cores or specialized artificial neurons (neurers).</p>
<p>The large number of electronic modules must be handled by central facilities. If the gridpoint modules must organize the joint work in their (otherwise) payload time, the payload efficiency strongly degrades as the number of modules grow. Because of this, an <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> has a top layer (for the foreground activities, like computations) and a bottom layer (for the background activities, like operating the communication (sending, receiving and forwarding messages). The top layer can work in two regimes. In the conventional regime the module works in a conventional way (like the core processes conventional instructions) and in the meta-regime it executes meta-instructions (configuration). Both kinds of operations are built up from elementary steps (in the conventional regime: machine instructions, in the meta regime: elementary configuration step, after which processing can continue in a reasonable way). In both regimes all resources are utilized, so an elementary action can be either conventional or meta action, but only one at a time, and the action must be completed before the next action can be taken.</p>
<p>The operation of the bottom layer is only loosely coupled to that of the upper layer. The upper layer uses the bottom layer "as a service": can send and receive messages to/from the other gridpoints, with as little overhead as possible: the load of synchronization, routing, delivering is on the bottom layer.</p>
<p>The topology introduced above enables the members of the cluster to reach each other either directly or through the cluster head as a proxy: the common boundaries enable to prepare dual-access elements, (communication channels) in this way implementing a direct way of communication (i.e. without the need of any global bus, see section <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#TAC_BASIC_TECHNICAL_Breakdown_IGPCB">The inter-gridpoint communication block</a>). The communication is a native feature of the grid points: they communicate in the background (when needed), independently of the foreground activity the gridpoint makes.</p>
<p>From communication point of view, the best idea is to consider that the modules have (logically) hexagonal shape, they have neighbors and through the common boundaries they can exchange data using a mechanism very similar to those used inside the cores. This "gridpoint-to-gridpoint bus" (the lowest level in the hierarchy) is actually not really a bus. Rather, it is a dedicated point-to-point connection, without latency time and contention, i.e. a very high speed transfer between the neighboring cores.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Breakdown_scHThreads"></a>
HThreads and computing resources</h2>
<p>With the technical development, the <em>processing</em> time of computing by procssing units is continuosly getting shorter than <em>transferring</em> the data to the place of processing. Because of this, the processing unit if blocked by the missing data. To overcome this very pure utilization of the processing unit, hardware threads <a class="el" href="classscHThread.html" title="The scHThread class.">scHThread</a> has been introduced. The idea is taken from the <a class="el" href="GLOSSARY.html#GLOSSARY_SW">SW</a> idea of threads, but the HThreads have also <a class="el" href="GLOSSARY.html#GLOSSARY_HW">HW</a> attributes, such as internal registers, state flags, cache registers, and so on.</p>
<p>The computing is based on <a class="el" href="classscHThread.html" title="The scHThread class.">scHThread</a> units. When a computing thread (represented by an <a class="el" href="classscHThread.html" title="The scHThread class.">scHThread</a>) is ready to run, it sends a request to its processor core. If that request is not busy, the <a class="el" href="classscHThread.html" title="The scHThread class.">scHThread</a> "owns" it for the time it needs it: the other <a class="el" href="classscHThread.html" title="The scHThread class.">scHThread</a> units attached to the same <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a>, will be able to run only if the current <a class="el" href="classscHThread.html" title="The scHThread class.">scHThread</a> released the computing resource. Given that the <a class="el" href="classscHThread.html" title="The scHThread class.">scHThread</a> processes spend most of their time with waiting for data or for each other, this method enables to maximize utilization of the computing resource.</p>
<p>The operation on the <a class="el" href="classscHThread.html" title="The scHThread class.">scHThread</a> is completely transparent for the programmer. The programmer simply starts a <a class="el" href="GLOSSARY.html#GLOSSARY_SW">SW</a> process on a <a class="el" href="classscHThread.html" title="The scHThread class.">scHThread</a>, and the process runs as the current <a class="el" href="GLOSSARY.html#GLOSSARY_HW">HW</a> situation enables it.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Breakdown_HexaExtended"></a>
The extended cluster</h2>
<p>Notice that</p><ul>
<li>the cluster members have common boundaries with members of other clusters</li>
<li>the communication through a proxy member must also be implemented inside the cluster</li>
</ul>
<p>This feature can be used to implement a special way of inter-cluster communication. The communication channels are built on all boundaries where on both sides a <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a> is present. This serves primarily inter-cluster communication. However, the gridpoints having a common boundary with the members of the cluster may use that cluster member as a proxy; i.e they can be considered as an "external member" of the cluster. The "external member" <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a> can be addressed by coordinates (C,M,P), where C is the number of the cluster, P is the member used as a proxy, and M is the "external member" described in the same way as a member: relative to P.</p>
<p>Even, the morphing of the architecture enables to re-group some <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a> objects from one cluster to another, provided that the primary member of the donor cluster is a secondary member of the acceptor cluster. In this way quite large clusters (comprising altogether 1+6+12 members) can be created. Another useful possibility is to group the usable cluster members of a faulty cluster head to another cluster, in this way losing only one <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a>, rather than a whole cluster.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Breakdown_scProcessor"></a>
The processor comprising scGridPoint modules</h2>
<p>The next higher order unit is <a class="el" href="classscProcessor.html" title="Implements a module-name alias facility (i.e., user-provided names. Given that the basic units is scH...">scProcessor</a>, the <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> modules belong to. The processor does not make calculations. Instead, it organizes the job, and oversees the operation of its cores. It handle the resources, including borrowing them for collective operations.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Breakdown_MessageRouting"></a>
Message routing</h2>
<p>The <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> modules represent the bottom layer of the subclassed modules such the different processors (including also neurers) and one of their task is to route the messages to the right place autonomously, using only the information compressed in the message and without the help of the top layer.</p>
<p>Notice that the modules with distance two can be reached using the common neighbor as a proxy. This feature is independent from whether the gridpoints belong to the same cluster.</p>
<p>The hierarchic addressing enables to implement the purely address-based routing easily. However, as the direct message transfer is implemented independently from the cluster architecture (i.e. a direct connection channel between <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> modules belonging to different clusters also exists), an additional method, the "forced direct" transfer is also implemented. It means, that if the transfer can be solved without using inter-cluster bus (say, the source and the destination belong to two different clusters, but are first or second orer neighbors), the direct transfer is preferred. This complicates routing, but enables speedier message transfer and considerably increases the capabilities of the <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> (and the subclasses derived from it).</p>
<p>The details of the routing method are given in scGridPoint::RouteMessage. The message source (and <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a>) assembles the message and calls this function; the rest is for the underlying architecture. This method enables <a class="el" href="GLOSSARY.html#GLOSSARY_QT">QT</a> handling, including "remote procedure calls" and "in-memory calculations".</p>
<h1><a class="anchor" id="BASE_TECHNICAL_GUIDE_ClusterBus"></a>
The ClusterBus</h1>
<p>The clusters between each other can communicate using the scClusterBus bus. Every single <em>cluster head</em> is connected to the bus, plus the rest of the components. The formers have natively have <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#TAC_BASIC_TECHNICAL_Addressing_ClusterHead">The cluster head</a> has natively its <a class="el" href="structClusterAddress__t.html" title="A GridPoint can be addressed also by its cluster address of type ClusterAddress_t....">ClusterAddress_t</a> address, the other are subclassed from <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a>, i.e. they have all the functionality of an <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a>, plus some extra functionality. The figure in section <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#BASE_TECHNICAL_GUIDE_ClusterBus_Scheme">The scClusterBus scheme</a> shows how tose elements are connected together. Notice that here the communication between components is natively belonging to the components: the communicating modules address what they want and the rest is the task of the bus and the partners. The control and data synchronization happens at <a class="el" href="GLOSSARY.html#GLOSSARY_HW">HW</a> level, rather than <a class="el" href="GLOSSARY.html#GLOSSARY_OS">OS</a> level.</p>
<p>The idea is that the cooperation data and control information transfer should be kept at the lowest level and as local as possible. Especially in large (meaning either large number and/or large physical size) systems the scalability is rather wrong as the size of the system increases. The conventional technology requires to use some kind of granularity of singleton units (say imagine cores, processors, cards, racks, etc.), and the units at different levels are connected via a singleton high-performance bus. Here a simple hierarchic bus system model is proposed that is inherently able to separate the bus traffic into 'local' and 'remote' traffic, at several levels.</p>
<h2><a class="anchor" id="BASE_TECHNICAL_GUIDE_ClusterBus_Hierarchy"></a>
The hierarchic buses</h2>
<p>Both scIGPCB and scClusterBus are part of the hierarchic bus system. While for in-cluster communication a special direct connection (the scIGPCB modules, i.e. not a bus in the conventional sense) is used, scClusterBus is a conventional bus: it delivers messages from one cluster to another. In technical sense, only the cluster heads are connected to the bus, the non-head points can reach each other via sending their messages to <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#TAC_BASIC_TECHNICAL_Addressing_ClusterHead">The cluster head</a>.</p>
<p>The cluster heads comprise a communication gateway element, that enables them to send the messages to another cluster. Similarly, the <a class="el" href="classscProcessor.html" title="Implements a module-name alias facility (i.e., user-provided names. Given that the basic units is scH...">scProcessor</a> contains the next level gateway (not implemented at the present stage of development) to connect the processors, and similar gateways are present at the higher levels of hierachy.</p>
<h2><a class="anchor" id="BASE_TECHNICAL_GUIDE_ClusterBus_Scheme"></a>
The scClusterBus scheme</h2>
<p>This is the description of a simple abstract bus model, for a higher performance modeling, especially for <a class="el" href="GLOSSARY.html#GLOSSARY_EMPA">EMPA</a> comprising <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> modules. The modeling is done at Transaction Level, and is based on cycle-based synchronization. The different components of the system are connected to a special bus as shown on the figure below.</p>
<div class="fragment"><div class="line">---------------------------------------------------------------------------</div>
<div class="line">      +---------+   +---------+   +---------+</div>
<div class="line">      |Cluster#0|   |Cluster#1|   |Cluster#N|</div>
<div class="line">  +--&gt;|head M/S |--&gt;|head M/S |...|head M/S |</div>
<div class="line">  |   +-- [*]---+   +---[*]---+   +---[*]---+</div>
<div class="line">  |        |             |             |</div>
<div class="line">  |        +-------------+-------------+</div>
<div class="line">  |                      |</div>
<div class="line">  |      /--------------(.)--------------\</div>
<div class="line">  +-&gt;[*]/        cluster_bus              \          +----------+</div>
<div class="line">  |     \                                 /[*]----(.)| arbiter  |</div>
<div class="line">  |      \--------------[*]--------------/           +----------+</div>
<div class="line">  |                     | |</div>
<div class="line">  |       ______________/ \__________________</div>
<div class="line">clock    /             /          \          \-</div>
<div class="line">  |      |            |           |           |</div>
<div class="line">  |   +--(.)--+   +--(.)--+   +--(.)--+   +--(.)--+      legend:</div>
<div class="line">  |   |Memory0|   |Memory1|   |Memory2|   |Memory3|         [*] : port</div>
<div class="line">  +--&gt;|type MS|   |type MS|   |type MS|   |type MS|         (.) : interface</div>
<div class="line">      +-------+   +-------+   +-------+   +-------+</div>
<div class="line"> </div>
<div class="line">  Figure 1: The EMPA intercluster _bus with M/S cluster heads,</div>
<div class="line">  the four memories and the arbiter.</div>
<div class="line">---------------------------------------------------------------------------</div>
</div><!-- fragment --><h2><a class="anchor" id="BASE_TECHNICAL_GUIDE_ClusterBus_MasterSlave"></a>
Masters and slaves</h2>
<p>The modules connected to the bus must 'own' the bus for the time of their data transfer. The scClusterBusArbiter is contacted by the modules via issueing a <a class="el" href="structClusterBusRequest.html" title="A GridPoint can be addressed also by its cluster address of type ClusterAddress_t.">ClusterBusRequest</a> The conventional principle of sharing the scClusterBus is kept: via the scClusterBusArbiter arbiter unit, a master can request the only available bus and its access can be granted, in different forms. Any of the modules are able to send message to any other. To do so, all modules connected to the bus have <em>both</em> master and slave interfaces, see scClusterBusMaster_blocking and <a class="el" href="classscClusterBusMemorySlow.html" title="The &#39;far&#39; memory of the processor.">scClusterBusMemorySlow</a>. (Yes, the memories can directly send messages to each other: think about cache operation and gls{I/O} buffering)</p>
<p>All modules connected to the bus have their unique <a class="el" href="structClusterAddress__t.html" title="A GridPoint can be addressed also by its cluster address of type ClusterAddress_t....">ClusterAddress_t</a> address and as masters, they have also their unique bus access priority. For details see the corresponding sources. This is just the technical way of connecting the modules, allowing them to transfer data from one scGrisPoint to another; it should not be mismatched with the the cooperation of the modules, described in section <a class="el" href="TAC_BASIC_TECHNICAL_Cooperation_Page.html">The cooperation</a>.</p>
<p>Given the limited capacity of the developer, in this early phase of development at some places the bus operation is only imitated (i.e. momentaily replaced with a direct access plus timing delay). This does not affect basically the viability and feasibilty of the operating regime, however the exact timing may be slightly different from the simulated one.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Breakdown_IGPCB"></a>
The inter-gridpoint communication block</h2>
<p>The special arrangement of the computing elements enable to use "local" and "distance" traffic in the computing elements.</p>
<p>Along the common boundaries special electronic blocks scIGPCB are prepared; always in pairs, originating and ending in the modules at the two sides of the boundary, and making a direct connection in both directions. This simple "bus" (implemented as a FIFO) is wired directly to the other party, the sending modules writes directly to the party's FIFO, where the receiver puts the received message into latch registers utils finally processed.</p>
<p>There are as many scIGPCB modules in as <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a>, as many common boundaries of the representing hexagon with some other hexagon. (there is no connection with the "violet" (phantom) members, but there is with the "white" (external) members). There is no competition, no arbitration, no synchronization need, no setup time. The neighbor's buffer is simply part of the module (if it is represented as a FIFO, it is read by the owner module and written by the corresponding neighbor).</p>
<p>The sender assembles the message (including the response address) and initiates the transfer, but after that it shall not wait, the transfer is carried out in the background. The sender can, but should not, wait until the transfer is complete. Sending more messages to the same neighbor is blocked until the transfer completes, but sending messages to other neighbors does not interfere with sending the message.</p>
<p>The sending scIGPCB notifies its owner <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> when the transfer is done and puts the received message in another FIFO (in the <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a>).</p>
<p>They scIGPCB submodules serve as a special buffer during the communication among the <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> modules. An <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> sends and receives an <a class="el" href="classscIGPMessage.html" title="The scIGPMessage class.">scIGPMessage</a> to/from its party on the other side of the boundary autonomously, without needing external control and any additional action from the two modules, it does not contribute to the non-payload activity. The receiving scIGPCB stores the message in a buffer, and parses it: the <a class="el" href="classscIGPMessage.html" title="The scIGPMessage class.">scIGPMessage</a> is self-contained, i.e. the scIGPCB can completely process the message. Depending on the message type, the scIGPCB can copy register-like contents to the corresponding latches of the <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a>, or forward the message as a proxy to another neighbor, or to forward it (through it own cluster head) to the special cluster bus, request memory contents, or the same traffic in the opposite direction. The <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> (still in the background) processes the messages in the FIFO one-by-one and puts the relevant contents in latches, where it is immediately available for the foreground processing when needed.</p>
<p>The important principle that is followed: <em>the modules can send messages though their own scIGPCB when they feel to do so, and the other party reads the message from its own latches when it needs to do so (if the message is not present, it must wait, but no other synchronization is required)</em>.</p>
<h1><a class="anchor" id="TAC_BASIC_TECHNICAL_Addressing_GROUPING"></a>
Module grouping</h1>
<p>During fabrication, the modules are placed in a 2-dimensional structure, i.e. they have natively X and Y <em>coordinates</em> and they can easily be arranged to form a one-dimensional vector, i.e. they can also have natively a <em>unique sequence number</em> (it is arranged column-wise). The grid points (<a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> units) are technologically arranged (and also by technologically: the even rows/columns are shifted by a half grid position). That is, a module can be referred to by a single index (scProcessor::ByID_Get(int ID)), a pair of indices (<a class="el" href="classscProcessor.html#a8d266318f3e788338b5b0c15870147ef" title="Get an scGridPoint by its indices.">scProcessor::ByIndex_Get(int X,int Y)</a>), and a pair of coordinates (scProcessor::ByPosition_Get(int XPos,int YPos)); they all refer to the same physical module.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Addressing_CLUSTER"></a>
The Hexagonal cluster</h2>
<p>This special (<a class="el" href="GLOSSARY.html#GLOSSARY_CNN">CNN</a>-like arrangement enables us to consider the rectangular grid (logically) as a hexagonal grid. We can also interpret different neighborship relations. The <em>first order neighbors</em> have a common boundary, the <em>second order neighbors</em> have a common neighbor. In order to avoid half numbers, in direction Y the numbers are increasing by two rather than one (that is, in direction Y the <em>position</em> and the <em>index</em> differ by a factor of two). The modules have a common boundary with all their immediate neighbors and can be addressed by using relative coordinates; for example, neighbor <em>NE</em> means the neighbor module of the actual point in direction north-east. </p><div class="fragment"><div class="line">            \ N(X,Y+2) /</div>
<div class="line">             ---------</div>
<div class="line">NW(X-1,Y+1) /         \ NE(X+1,Y+1)</div>
<div class="line">   --------&lt;   (X,Y)   &gt;--------</div>
<div class="line">SW(X-1,Y-1) \         / SE(X+1,Y-1)</div>
<div class="line">             ---------</div>
<div class="line">            / S(X,Y-2)\</div>
</div><!-- fragment --><p>Also, the modules are organized to form functional clusters as shown in Figure <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#Fig_HexagonalCluster">Fig_HexagonalCluster</a>. The central module is called the <em>cluster head</em>, the others are the <em>cluster member</em>s. The position of the individual modules can be described with their relative position to their immediate neighbor (and maybe second neighbor), they have a <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#TAC_BASIC_TECHNICAL_Addressing_LOGICAL">special logical address</a>. In this way, a module may have different valid <em>relative addresses</em>, providing the advantage of having different paths when a message needs to reach them during routing.</p>
<p><a class="anchor" id="Fig_HexagonalCluster"></a></p><div class="image">
<img src="HexagonalCluster.png" alt="" width="300px"/>
<div class="caption">
Gridpoint as a hexagonal arrangement</div></div>
 <p>As shown in Figure <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#Fig_Hexagona2">Fig_Hexagona2</a> (the coordinates X and Y correspond to that of the rectangular grid). The rectangular grid is described by an <a class="el" href="classAbstractTopology.html">AbstractTopology</a>, where a vector, and a two-dimensional vector stores the address of the <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a> objects. Also, the cluster heads are stored in a special vector. Given those storage methods, the <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a> objects can be reached through different addressing methods, although the different addressing methods refer to the same physical module.</p>
<p>Notice that the common boundaries enable a special method of communication, <em>direct wiring</em>, which is the lowest level of the <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#TAC_BASIC_TECHNICAL_Addressing_HIERARCHIC">Hierarchic communication</a>. The blueish boxes are a special two-way communication unit (scIGPCB: the inter-gridpoint communication block), which enables a register-like communication between the direct neighbors.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Addressing_ProxyModules"></a>
The proxy modules</h2>
<p>The arrangement provides one more advantage. The direct wired scIGPCB blocks enable a (because of the direct wiring, economic) way of using proxy cores for messages. Any of the modules can serve as a proxy communication station for its neigbors. The special addressing mode <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#TAC_BASIC_TECHNICAL_Addressing_LOGICAL">Module's hierarchic logical addressing</a> enables to provide also a proxy address (it must be a first-order neighbor of the real target module), enabling to attach (denied or orphaned) modules to a "foreign" module.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Addressing_ClusterHead"></a>
The cluster head</h2>
<p>From addressing point of view, the head is a cluster member with in-cluster index ClusterNeighbor::cm_Head (zero) and of course has ClusterStatus::cs_Head. From architectural point of view, the cluster head is somewhat different from the simple members: they are 'fat' in the sense that they have two further elements. They have access to the inter-cluster bus (scClusterBus), which represents the next level of the <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#TAC_BASIC_TECHNICAL_Addressing_HIERARCHIC">Hierarchic communication</a>. The cluster heads (any only the heads) have access (wiring) to the memory system (M) and they serve as a gateway (G) to the higher-level <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#TAC_BASIC_TECHNICAL_Addressing_HIERARCHIC">Hierarchic communication</a>, the inter-processor bus (presently not implemented). The rest of cluster members is not wired to those external world; they must request their cluster head to proxy that functionality.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Addressing_ClusterPhantom"></a>
The phantom clusters</h2>
<p>Of course, a rectangular area cannot be covered with hexagonals without difficulties. As Figure <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#Fig_Hexagona2">Fig_Hexagona2</a> displays, there are incomplete clusters (where the cluster head exists but some of its first-order members are not implemented) and there are phantom clusters with orphan members: the member is physically implemented, but has no physical cluster head module (just a logical core: a phantom). The orphan cores are joined to one of the neighboring clusters during fabrication: they simply have a predefined proxy, so they can be used as a full-value <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a>; the only difference that in their address the <a class="el" href="structClusterAddress__t.html#acf14e4884465281332f182b26498e9ba" title="Reachable through this neighbor (Relative to the core)">ClusterAddress_t::Proxy</a> field is not zero.</p>
<p><a class="anchor" id="Fig_Hexagona2"></a></p><div class="image">
<img src="Hexagona2.png" alt="" width="500px"/>
<div class="caption">
The hexagonal arrangement of the gridpoints</div></div>
 <h1><a class="anchor" id="TAC_BASIC_TECHNICAL_Addressing_LOGICAL"></a>
Module's hierarchic logical addressing</h1>
<p>One of the key factors of scalability of computer networks is the sub-networking, i.e. communicating nodes are organized in a way that the communication takes place, as much as possible, within the subnetwork and only the part that targets other sub-network uses the higher level buses. The other key factor is that "the communication-to-computation ratio" is not much worse for the higher-level communication than that for the communication within the sub-network: the networking minimizes the number of "hops" needed to reach the destination.</p>
<p><a class="anchor" id="Fig_ClusterAddressing"></a></p><div class="image">
<img src="ClusterAddressing.png" alt="" width="500px"/>
<div class="caption">
The addressing mode used for hierarchic communication</div></div>
 <p>The cluster address is composed akin to the subnetworks of the computer networks. A cluster is composed of 1+6 gridpoints, leaving space for a "broadcast" type message, too.</p>
<p>The address of an <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> (otherwise <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a> #2) is given throughout this booklet as </p><div class="fragment"><div class="line">{0,0}=(7.H)</div>
<div class="line">{0,4}=(7.N:N)</div>
</div><!-- fragment --><p> where {Xpos,Ypos} are the <em>topological position</em> of the <a class="el" href="classGridPoint.html" title="This class handles the topological information for the modules. Provides a lot of math-only utility f...">GridPoint</a> and (Cluster.Member:Proxy) are the logical (cluster) address. The {Xpos,Ypos} coordinates enable to locate the <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> for the user on Figure <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#Fig_Hexagona2">Fig_Hexagona2</a>, and (Cluster.Member:Proxy) form enables the routing to deliver the message to its destination. Notice that proxy is not used in most of the cases; in such cases the default ':Proxy' is not displayed.</p>
<p>That is: {0,0} is the head of cluster 7; {0,4} is the north neighbor of the north member of cluster 7. Notice that some nodes have neighbors from a different cluster, so they might have two valid addresses: one with proxy using a foreign cluster head and one as ordinary element with their own proxy. This facility provides redumdanca and extraordinary facilitities on traffic organization. Say, </p><div class="fragment"><div class="line">{0,4}=(2.SW:NW)</div>
<div class="line">{0,4}=(2.NW:SW)</div>
</div><!-- fragment --><p> are also avalid access path to reach node </p><div class="fragment"><div class="line">{0,0}=(7.H)</div>
</div><!-- fragment --><p>This addressing gives way to <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#TAC_BASIC_TECHNICAL_Addressing_HIERARCHIC">Hierarchic communication</a>.</p>
<p>Given that the central elements (with orange color) have physically distinguished role, the usual way of addressing is to provide <a class="el" href="TAC_BASIC_TECHNICAL_Beakdown_PAGE.html#TAC_BASIC_TECHNICAL_Addressing_ClusterHead">The cluster head</a> in the address.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Addressing_PHYSICAL"></a>
The physical address</h2>
<p>The mentioned physical addresses can be used referring to an element of a vector or a matrix of the modules, but they must somehow be mapped to the network connecting them, also needing additional protocols.</p>
<h2><a class="anchor" id="TAC_BASIC_TECHNICAL_Addressing_ClusterAddress"></a>
The cluster addressing</h2>
<p>Similarly to computer networking, <em>any</em> of the native IDs can be used to address the <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> modules. The logical addressing is based on the <a class="el" href="structClusterAddress__t.html" title="A GridPoint can be addressed also by its cluster address of type ClusterAddress_t....">ClusterAddress_t</a> address that enables the set of the <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> modules to deliver the messages to their destination in the bottom layer of the <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> modules. In the present version only one <a class="el" href="classscProcessor.html" title="Implements a module-name alias facility (i.e., user-provided names. Given that the basic units is scH...">scProcessor</a> is assumed and used, but the addressing can be trivially extended to higher order modules (such as cards, racks, etc.) The only requirement is to distinguish one of the cluster heads, processors, etc. that has access to the higher level communication bus, and the message is automagically forwarded to any <a class="el" href="classscGridPoint.html" title="This class implements the autonomous grid point functionality: it is a communicating GridPoint....">scGridPoint</a> in the system. Presently <a class="el" href="structClusterAddress__t.html" title="A GridPoint can be addressed also by its cluster address of type ClusterAddress_t....">ClusterAddress_t</a> is assumed to have 32 bits.</p>
<h1><a class="anchor" id="TAC_BASIC_TECHNICAL_Addressing_HIERARCHIC"></a>
Hierarchic communication</h1>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Apr 7 2021 15:24:23 for TAC  V0.0.4 @ 2021.04.07 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
